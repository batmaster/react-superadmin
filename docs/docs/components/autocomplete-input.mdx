---
id: autocomplete-input
title: AutocompleteInput Component
sidebar_label: AutocompleteInput
description: Searchable select input with async data fetching and filtering
keywords: [autocomplete, search, select, input, async, filtering]
---

# AutocompleteInput Component

The AutocompleteInput component provides a searchable select input that supports async data fetching, filtering, and keyboard navigation. It's perfect for selecting from large datasets where users need to search and filter options.

## Import

```tsx
// AutocompleteInput component is available in the live scope
```

## Basic Usage

```tsx
<AutocompleteInput
  options={[
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Jane Smith' },
    { id: 3, name: 'Bob Johnson' }
  ]}
  getOptionLabel={(option) => option.name}
  getOptionValue={(option) => option.id}
  value={selectedUser}
  onChange={setSelectedUser}
  placeholder="Search users..."
/>
```

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `options` | `T[]` | `[]` | Array of available options |
| `value` | `T \| null` | - | Currently selected value |
| `onChange` | `(value: T \| null) => void` | - | Change handler function |
| `getOptionLabel` | `(option: T) => string` | - | Function to get display label from option |
| `getOptionValue` | `(option: T) => string \| number` | - | Function to get value from option |
| `placeholder` | `string` | - | Placeholder text |
| `disabled` | `boolean` | `false` | Whether the input is disabled |
| `required` | `boolean` | `false` | Whether the input is required |
| `name` | `string` | - | Input name attribute |
| `id` | `string` | - | Input ID attribute |
| `className` | `string` | - | Additional CSS classes |
| `size` | `'sm' \| 'md' \| 'lg'` | `'md'` | Input size variant |
| `error` | `string` | - | Error message to display |
| `helperText` | `string` | - | Helper text below the input |
| `loading` | `boolean` | `false` | Whether to show loading state |
| `noOptionsText` | `string` | `'No options'` | Text shown when no options match |
| `filterOptions` | `(options: T[], inputValue: string) => T[]` | - | Custom filter function |
| `onInputChange` | `(inputValue: string) => void` | - | Input change handler |
| `open` | `boolean` | - | Control dropdown open state |
| `onOpen` | `() => void` | - | Dropdown open handler |
| `onClose` | `() => void` | - | Dropdown close handler |

## Basic Examples

### Simple String Options

```tsx
const countries = ['United States', 'Canada', 'United Kingdom', 'Germany', 'France'];

<AutocompleteInput
  options={countries}
  value={selectedCountry}
  onChange={setSelectedCountry}
  placeholder="Select a country"
/>
```

### Object Options with Custom Labels

```tsx
const users = [
  { id: 1, firstName: 'John', lastName: 'Doe', email: 'john@example.com' },
  { id: 2, firstName: 'Jane', lastName: 'Smith', email: 'jane@example.com' },
  { id: 3, firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com' }
];

<AutocompleteInput
  options={users}
  value={selectedUser}
  onChange={setSelectedUser}
  getOptionLabel={(user) => `${user.firstName} ${user.lastName} (${user.email})`}
  getOptionValue={(user) => user.id}
  placeholder="Search users..."
/>
```

## Async Data Fetching

The AutocompleteInput component works great with async data sources:

```tsx
import { useState, useEffect } from 'react';

function AsyncAutocompleteInput() {
  const [options, setOptions] = useState([]);
  const [loading, setLoading] = useState(false);
  const [inputValue, setInputValue] = useState('');
  const [selectedValue, setSelectedValue] = useState(null);

  const fetchOptions = async (searchTerm) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/users?search=${searchTerm}`);
      const data = await response.json();
      setOptions(data);
    } catch (error) {
      console.error('Failed to fetch options:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (inputValue.length >= 2) {
      fetchOptions(inputValue);
    } else {
      setOptions([]);
    }
  }, [inputValue]);

  return (
    <AutocompleteInput
      options={options}
      value={selectedValue}
      onChange={setSelectedValue}
      onInputChange={setInputValue}
      loading={loading}
      getOptionLabel={(user) => user.name}
      getOptionValue={(user) => user.id}
      placeholder="Search users (type 2+ characters)..."
      noOptionsText={inputValue.length < 2 ? 'Type 2+ characters to search' : 'No users found'}
    />
  );
}
```

## Custom Filtering

You can provide custom filtering logic:

```tsx
<AutocompleteInput
  options={products}
  value={selectedProduct}
  onChange={setSelectedProduct}
  getOptionLabel={(product) => product.name}
  getOptionValue={(product) => product.id}
  filterOptions={(options, inputValue) => {
    if (!inputValue) return options;
    
    return options.filter(product => 
      product.name.toLowerCase().includes(inputValue.toLowerCase()) ||
      product.category.toLowerCase().includes(inputValue.toLowerCase()) ||
      product.sku.toLowerCase().includes(inputValue.toLowerCase())
    );
  }}
  placeholder="Search products by name, category, or SKU..."
/>
```

## Form Integration

The AutocompleteInput works seamlessly with form libraries:

```tsx
import { useForm } from 'react-hook-form';

function UserForm() {
  const { register, handleSubmit, setValue, watch, formState: { errors } } = useForm();
  const selectedUser = watch('userId');

  const handleUserChange = (user) => {
    setValue('userId', user?.id || '');
    setValue('userName', user?.name || '');
    setValue('userEmail', user?.email || '');
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Label htmlFor="user">Select User</Label>
        <AutocompleteInput
          id="user"
          options={users}
          value={users.find(u => u.id === selectedUser)}
          onChange={handleUserChange}
          getOptionLabel={(user) => user.name}
          getOptionValue={(user) => user.id}
          placeholder="Search and select a user..."
          error={errors.userId?.message}
        />
        {errors.userId && (
          <p className="text-sm text-red-600">{errors.userId.message}</p>
        )}
      </div>

      <div>
        <Label htmlFor="userName">User Name</Label>
        <Input
          id="userName"
          {...register('userName', { required: 'User name is required' })}
          readOnly
        />
      </div>

      <div>
        <Label htmlFor="userEmail">User Email</Label>
        <Input
          id="userEmail"
          {...register('userEmail', { required: 'User email is required' })}
          readOnly
        />
      </div>

      <Button type="submit">Submit</Button>
    </form>
  );
}
```

## Multiple Selection

You can enable multiple selection by using an array value:

```tsx
const [selectedUsers, setSelectedUsers] = useState([]);

<AutocompleteInput
  options={users}
  value={selectedUsers}
  onChange={setSelectedUsers}
  getOptionLabel={(user) => user.name}
  getOptionValue={(user) => user.id}
  multiple
  placeholder="Select multiple users..."
/>
```

## Custom Option Rendering

You can customize how options are displayed:

```tsx
<AutocompleteInput
  options={products}
  value={selectedProduct}
  onChange={setSelectedProduct}
  getOptionLabel={(product) => product.name}
  getOptionValue={(product) => product.id}
  renderOption={(product, { selected }) => (
    <div className="flex items-center space-x-3">
      <img 
        src={product.image} 
        alt={product.name} 
        className="w-8 h-8 rounded"
      />
      <div className="flex-1">
        <div className="font-medium">{product.name}</div>
        <div className="text-sm text-gray-500">{product.category}</div>
      </div>
      <div className="text-sm font-medium">${product.price}</div>
    </div>
  )}
  placeholder="Select a product..."
/>
```

## Loading States

Show loading indicators during async operations:

```tsx
<AutocompleteInput
  options={options}
  value={selectedValue}
  onChange={setSelectedValue}
  loading={isLoading}
  loadingText="Loading users..."
  placeholder="Search users..."
/>
```

## Error Handling

Display error states and messages:

```tsx
<AutocompleteInput
  options={options}
  value={selectedValue}
  onChange={setSelectedValue}
  error="Failed to load users"
  helperText="Please try again or contact support"
  placeholder="Search users..."
/>
```

## Accessibility

The AutocompleteInput component includes comprehensive accessibility features:

- Proper ARIA labels and descriptions
- Keyboard navigation support
- Screen reader compatibility
- Focus management
- Error state announcements

```tsx
<AutocompleteInput
  id="user-select"
  aria-describedby="user-help user-error"
  aria-invalid={!!errors.userId}
  options={users}
  value={selectedUser}
  onChange={setSelectedUser}
  getOptionLabel={(user) => user.name}
  getOptionValue={(user) => user.id}
  placeholder="Search and select a user"
  error={errors.userId?.message}
  helperText="Type to search for users by name or email"
/>
```

## Examples

### User Selection with Company Filtering

```tsx
function UserSelectionWithCompany() {
  const [users, setUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [companyFilter, setCompanyFilter] = useState('');

  const filteredUsers = users.filter(user => 
    !companyFilter || user.company === companyFilter
  );

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="company">Filter by Company</Label>
        <SelectInput
          id="company"
          value={companyFilter}
          onChange={setCompanyFilter}
          options={[
            { value: '', label: 'All Companies' },
            { value: 'Acme Corp', label: 'Acme Corp' },
            { value: 'Tech Solutions', label: 'Tech Solutions' },
            { value: 'Global Industries', label: 'Global Industries' }
          ]}
        />
      </div>

      <div>
        <Label htmlFor="user">Select User</Label>
        <AutocompleteInput
          id="user"
          options={filteredUsers}
          value={selectedUser}
          onChange={setSelectedUser}
          getOptionLabel={(user) => `${user.name} - ${user.company}`}
          getOptionValue={(user) => user.id}
          placeholder="Search users..."
          noOptionsText={
            companyFilter 
              ? `No users found in ${companyFilter}` 
              : 'No users available'
          }
        />
      </div>
    </div>
  );
}
```

### Product Search with Categories

```tsx
function ProductSearch() {
  const [products, setProducts] = useState([]);
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');

  const searchProducts = async (term) => {
    if (term.length < 2) return;
    
    try {
      const response = await fetch(`/api/products/search?q=${term}`);
      const data = await response.json();
      setProducts(data);
    } catch (error) {
      console.error('Search failed:', error);
    }
  };

  useEffect(() => {
    const debounceTimer = setTimeout(() => {
      searchProducts(searchTerm);
    }, 300);

    return () => clearTimeout(debounceTimer);
  }, [searchTerm]);

  return (
    <AutocompleteInput
      options={products}
      value={selectedProduct}
      onChange={setSelectedProduct}
      onInputChange={setSearchTerm}
      getOptionLabel={(product) => product.name}
      getOptionValue={(product) => product.id}
      placeholder="Search products..."
      noOptionsText={
        searchTerm.length < 2 
          ? 'Type 2+ characters to search' 
          : 'No products found'
      }
      renderOption={(product) => (
        <div className="flex items-center space-x-3">
          <img 
            src={product.image} 
            alt={product.name} 
            className="w-10 h-10 rounded object-cover"
          />
          <div className="flex-1">
            <div className="font-medium">{product.name}</div>
            <div className="text-sm text-gray-500">
              {product.category} • ${product.price}
            </div>
          </div>
        </div>
      )}
    />
  );
}
```

## Best Practices

1. **Debounce search inputs** - Avoid excessive API calls while typing
2. **Provide meaningful labels** - Use descriptive option labels
3. **Handle loading states** - Show feedback during async operations
4. **Implement proper error handling** - Gracefully handle API failures
5. **Use appropriate filter logic** - Consider search relevance and performance
6. **Test keyboard navigation** - Ensure accessibility compliance
7. **Optimize option rendering** - Use virtualization for large datasets

## Related Components

- [SelectInput](/docs/components/select-input) - For simple dropdown selection
- [Input](/docs/components/input) - For basic text input
- [Form](/docs/components/form) - For form containers and validation
- [Label](/docs/components/label) - For form field labels
- [Button](/docs/components/button) - For form submission and actions

