# Development Workflow and Best Practices

## Development Commands

### Core Development

```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Build packages
pnpm build              # Build both packages
pnpm build:core         # Build core package only
pnpm build:web          # Build web package only

# Type checking
pnpm typecheck          # Check types for both packages
```

### Testing Workflow

```bash
# Run all tests
pnpm test

# Run specific package tests
pnpm test:core         # Core package tests
pnpm test:web          # Web package tests

# Development testing
pnpm test:watch        # Watch mode for development
pnpm test:coverage     # Generate coverage reports

# Use custom test script
./scripts/test.sh      # Run all tests
./scripts/test.sh core # Run core tests only
./scripts/test.sh -w   # Watch mode
./scripts/test.sh -c   # Coverage mode
```

### Code Quality

```bash
# Linting
pnpm lint              # Lint both packages

# Clean build artifacts
pnpm clean             # Clean both packages
```

## Development Workflow

### 1. Feature Development

1. **Create feature branch** from main
2. **Implement feature** following established patterns
3. **Write tests** for new functionality
4. **Update documentation** if needed
5. **Run tests** to ensure everything works
6. **Submit pull request** with clear description

### 2. Testing Strategy

- **Write tests first** (TDD approach) for complex logic
- **Test all user interactions** and edge cases
- **Maintain 90%+ coverage** for critical paths
- **Use meaningful test descriptions** that explain behavior

### 3. Code Organization

- **Follow established patterns** for components, hooks, and utilities
- **Use consistent naming conventions** (PascalCase for components, camelCase for functions)
- **Group related functionality** in appropriate directories
- **Export from index files** for clean imports

### 4. TypeScript Usage

- **Define interfaces** for all props and data structures
- **Use generics** for flexible, reusable components
- **Avoid `any` types** - use proper typing
- **Leverage union types** for variant props

## File Organization Standards

### Component Files

```
src/components/
├── ui/                 # Reusable UI components
│   ├── Button.tsx
│   ├── Card.tsx
│   └── index.ts
├── layout/             # Layout components
│   ├── AdminLayout.tsx
│   ├── Sidebar.tsx
│   └── index.ts
└── crud/               # CRUD-specific components
    ├── ResourceList.tsx
    ├── ResourceForm.tsx
    └── index.ts
```

### Hook Files

```
src/hooks/
├── useResource.ts      # Resource management
├── useForm.ts          # Form handling
├── useTable.ts         # Table operations
└── index.ts            # Export all hooks
```

### Utility Files

```
src/utils/
├── createResource.ts   # Resource creation
├── createAdmin.ts      # Admin configuration
├── validation.ts       # Validation logic
├── formatting.ts       # Data formatting
└── index.ts            # Export all utilities
```

### Test Files

```
src/__tests__/
├── setup.ts            # Test configuration
├── utils/              # Test utilities
│   └── test-utils.tsx
├── components/         # Component tests
│   └── ui/
│       └── Button.test.tsx
├── hooks/              # Hook tests
└── utils/              # Utility tests
```

## Code Style Guidelines

### React Components

- Use functional components with TypeScript
- Implement proper prop interfaces
- Use destructuring for props
- Implement proper error boundaries
- Handle loading and error states

### Hooks

- Use `use` prefix for custom hooks
- Return objects with named properties
- Use `useCallback` for functions passed as props
- Use `useMemo` for expensive calculations
- Implement proper cleanup in `useEffect`

### Utilities

- Write pure functions when possible
- Validate inputs and provide helpful errors
- Use TypeScript for all parameters and returns
- Include JSDoc comments for complex functions
- Handle edge cases gracefully

### Testing

- Test behavior, not implementation
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)
- Mock external dependencies
- Test error states and edge cases

## Performance Considerations

### React Optimization

- Use `React.memo` for expensive components
- Implement proper dependency arrays in hooks
- Avoid unnecessary re-renders
- Use `useCallback` and `useMemo` appropriately

### Bundle Optimization

- Tree-shake unused exports
- Use dynamic imports for code splitting
- Optimize images and assets
- Minimize bundle size

### Testing Performance

- Mock expensive operations
- Use test isolation
- Clean up resources after tests
- Avoid testing implementation details

## Documentation Standards

### Code Comments

- Use JSDoc for public APIs
- Explain complex business logic
- Document non-obvious decisions
- Keep comments up to date

### README Files

- Clear installation instructions
- Usage examples
- API documentation
- Contributing guidelines

### Testing Documentation

- Test setup instructions
- Coverage requirements
- Testing patterns and examples
- Troubleshooting guide

## Quality Assurance

### Pre-commit Checklist

- [ ] All tests pass
- [ ] TypeScript compilation successful
- [ ] Linting passes
- [ ] Code follows established patterns
- [ ] Documentation updated if needed

### Pull Request Requirements

- Clear description of changes
- Tests for new functionality
- Updated documentation if needed
- No breaking changes without migration guide
- Performance impact considered

### Release Process

- Update version numbers
- Generate changelog
- Run full test suite
- Build all packages
- Publish to npm registry
  description:
  globs:
  alwaysApply: false

---

# Development Workflow Rules

## Git Commit Strategy

### Component Implementation Commits

- **Commit each component separately** - One component per commit for better tracking
- **Use detailed commit messages** with bullet points describing what was implemented
- **Follow conventional commit format** - `feat(component): add ComponentName with features`
- **Include implementation details** in commit body as bullet points

### Commit Message Format

```
feat(component): add ComponentName with features

• Implemented ComponentName component with TypeScript support
• Added props: prop1, prop2, prop3 for customization
• Included variants: variant1, variant2 for different styles
• Added accessibility features: aria-labels, keyboard navigation
• Implemented responsive design with Tailwind CSS
• Added comprehensive unit tests with Jest and React Testing Library
• Created detailed documentation with examples and API reference
• Added to component library and exported from index
```

### Testing Requirements

- **Unit tests required** for all components using Jest + React Testing Library
- **Test coverage minimum** 80% for critical components
- **Test all props and variants** to ensure functionality
- **Test accessibility features** and keyboard navigation
- **Test responsive behavior** on different screen sizes

### Documentation Requirements

- **Component API documentation** with all props and types
- **Usage examples** with live code demos
- **Accessibility guidelines** and best practices
- **Integration examples** showing how to use with other components
- **Performance considerations** and optimization tips

## Component Development Process

### 1. Implementation Phase

- Create component with TypeScript interfaces
- Implement core functionality and variants
- Add accessibility features (ARIA labels, keyboard nav)
- Style with Tailwind CSS following design system

### 2. Testing Phase

- Write comprehensive unit tests
- Test all props, variants, and edge cases
- Ensure accessibility compliance
- Verify responsive behavior

### 3. Documentation Phase

- Create component documentation page
- Add usage examples and live demos
- Document all props and types
- Include integration examples

### 4. Integration Phase

- Add to component library exports
- Update main index files
- Add to navigation and sidebar
- Update component overview pages

### 5. Commit Phase

- Commit component implementation
- Commit tests separately if large
- Commit documentation separately if large
- Use detailed commit messages with bullet points
