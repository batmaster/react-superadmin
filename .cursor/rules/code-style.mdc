# Code Style & Patterns

## Naming Conventions
- **Components**: Use PascalCase (e.g., `DataTable`, `ResourceForm`, `AdminLayout`)
- **Hooks**: Use camelCase with 'use' prefix (e.g., `useAuth`, `useResource`, `useForm`)
- **Functions**: Use camelCase (e.g., `createAdmin`, `formatCurrency`, `validateEmail`)
- **Constants**: Use UPPER_SNAKE_CASE (e.g., `API_BASE_URL`, `DEFAULT_PAGE_SIZE`)
- **Types/Interfaces**: Use PascalCase (e.g., `User`, `ResourceConfig`, `FormField`)

## Import Organization
```typescript
// 1. External libraries
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

// 2. Internal packages (core)
import { useResource, useAuth } from '@react-superadmin/core';

// 3. Internal components
import { Button } from '../ui/Button';
import { FormField } from '../forms/FormField';

// 4. Types
import type { User, ResourceConfig } from '../../types';

// 5. Utilities
import { formatCurrency, validateEmail } from '../../utils';
```

## Component Structure
```typescript
import React from 'react';
import type { ComponentProps } from './types';

interface ButtonProps extends ComponentProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  children,
  className,
  ...props
}) => {
  // 1. Hooks
  const [internalState, setInternalState] = useState(false);
  
  // 2. Event handlers
  const handleClick = () => {
    // handler logic
  };
  
  // 3. Computed values
  const buttonClasses = `btn btn-${variant} btn-${size} ${className || ''}`.trim();
  
  // 4. Render
  return (
    <button
      className={buttonClasses}
      disabled={loading}
      onClick={handleClick}
      {...props}
    >
      {loading ? <Spinner /> : children}
    </button>
  );
};
```

## Hook Patterns
```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';

export const useResource = <T>(resourceName: string, options?: ResourceOptions) => {
  // 1. State
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // 2. Memoized values
  const hasData = useMemo(() => data.length > 0, [data]);
  
  // 3. Callbacks
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await api.fetch(resourceName);
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [resourceName]);
  
  // 4. Effects
  useEffect(() => {
    if (options?.autoFetch) {
      fetchData();
    }
  }, [fetchData, options?.autoFetch]);
  
  // 5. Return object
  return {
    data,
    loading,
    error,
    fetchData,
    hasData,
  };
};
```

## TypeScript Best Practices
- **Use interfaces for object shapes**: `interface User { id: string; name: string; }`
- **Use type aliases for unions**: `type ButtonVariant = 'primary' | 'secondary' | 'danger'`
- **Use generics for reusable components**: `interface DataTableProps<T> { data: T[]; }`
- **Use utility types**: `Partial<User>`, `Pick<User, 'id' | 'name'>`, `Omit<User, 'password'>`
- **Use strict null checks**: Always handle undefined/null cases explicitly

## Error Handling
```typescript
// Use Result pattern for operations that can fail
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Use Error Boundaries for component errors
class ErrorBoundary extends React.Component<Props, State> {
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
}

// Use try-catch for async operations
try {
  const result = await api.fetch('/users');
  setUsers(result);
} catch (error) {
  setError(error instanceof Error ? error.message : 'Unknown error');
}
```

## Performance Patterns
- **Use React.memo for expensive components**: `export const ExpensiveComponent = React.memo(Component)`
- **Use useMemo for expensive calculations**: `const expensiveValue = useMemo(() => heavyCalculation(data), [data])`
- **Use useCallback for stable references**: `const stableCallback = useCallback(() => doSomething(id), [id])`
- **Use lazy loading for routes**: `const AdminPanel = lazy(() => import('./AdminPanel'))`
- **Use virtualization for large lists**: Implement virtual scrolling for tables with many rows

## Accessibility
- **Use semantic HTML**: `<button>`, `<nav>`, `<main>`, `<section>`
- **Add ARIA labels**: `aria-label="Search users"`, `aria-describedby="search-help"`
- **Support keyboard navigation**: Tab order, Enter/Space for buttons, Escape for modals
- **Provide alt text for images**: `<img alt="User avatar" src="avatar.jpg" />`
- **Use proper heading hierarchy**: `<h1>`, `<h2>`, `<h3>` in logical order
description:
globs:
alwaysApply: false
---
